<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAKING SOFTWARE - A reference manual for people who design and build software</title>
    <link rel="stylesheet" href="making-software.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="page">
        <!-- Grid Background -->
        <div class="grid-background"></div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 class="title" id="typewriter-title">TECH & ETHICS CLUB </h1>
                <div class="dotted-line"></div>
            </div>
            <div class="header-right">
                <div class="blueprint-info">
                    <div class="info-item">
                        <span class="label">DOCUMENT ID:</span>
                        <span class="value">FTL.001</span>
                    </div>
                    <div class="info-item">
                        <span class="label">VERSION:</span>
                        <span class="value">1.5</span>
                    </div>
                    <div class="info-item">
                        <span class="label">STATUS:</span>
                        <span class="value">ACTIVE</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Navigation -->
        <nav class="navigation">
            <div class="nav-container">
                <button class="nav-button" onclick="scrollToSection('gallery')">
                    <span class="nav-icon">ðŸ“·</span>
                    <span class="nav-text">GALLERY</span>
                </button>
                <button class="nav-button" onclick="scrollToSection('contact')">
                    <span class="nav-icon">ðŸ“§</span>
                    <span class="nav-text">CONTACT US</span>
                </button>
            </div>
        </nav>

        <!-- Page Markers -->
        <div class="page-marker left">FTL.001</div>
        <div class="page-marker right">1.5</div>

        <!-- Main Content -->
        <main class="content">
            <!-- Left Column -->
            <div class="column left-column">
                <!-- 3D Robot Playground Section -->
                <section class="section blueprint-section model-section">
                    <div class="section-header">
                        <h2 class="section-title"></h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="model-container">
                        <div id="robot-viewer" class="robot-viewer"></div>
                        <!--<div class="model-controls">
                            <div class="control-info">
                                <span class="control-label">CONTROLS:</span>
                                <span class="control-text">Mouse drag to rotate â€¢ Scroll to zoom â€¢ Right-click to pan</span>
                            </div>
                        </div> -->
                    </div>
                </section>

                <!-- About Us Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">ABOUT US</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                           Tech & Ethics Club is a student-led community for builders, coders, designers, and engineers from all corners of tech â€” from computer science and robotics to AI, hardware, and beyond. We host hackathons and hands-on challenges that push members to not only build amazing things, but to think deeply about why they're building them and who they're building for.
                        </p>
                        <p class="blueprint-text">
                            We believe technology isn't neutral â€” it shapes the world around us. That's why our focus goes beyond code. We explore the ethical impact of innovation, challenge ourselves to design for equity, privacy, sustainability, and inclusion, and create space for interdisciplinary collaboration.
                        </p>
                        <p class="blueprint-text">
                            Whether you're a beginner or an expert, a roboticist or a web dev, this is a club where you can build, compete, and grow â€” all while asking the big questions about tech's role in society.
                        </p>
                    </div>
                </section>

                <!-- Autonomous Robot Sweeper Section -->
                <section class="section blueprint-section model-section">
                    <div class="section-header">
                        <h2 class="section-title">AUTONOMOUS ROBOT SWEEPER</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="model-container">
                        <div id="sweeper-viewer" class="robot-viewer"></div>
                    </div>
                </section>

                <!-- Gaussian Blur Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">GAUSSIAN BLUR ALGORITHM</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                            The Gaussian blur algorithm applies a mathematical convolution to create smooth, natural-looking blur effects. This process involves sampling neighboring pixels and applying weighted averages based on the Gaussian distribution.
                        </p>
                        <p class="blueprint-text">
                            Kernel size and sigma values determine the intensity and radius of the blur effect. Larger kernels produce more pronounced blurring while maintaining computational efficiency through optimized sampling patterns.
                        </p>
                        <p class="blueprint-text">
                            The algorithm implements a two-pass approach: first applying the blur horizontally, then vertically. This separable convolution technique reduces computational complexity from O(nÂ²) to O(2n) for improved performance.
                        </p>
                    </div>
                </section>


            </div>

            <!-- Right Column -->
            <div class="column right-column">
                <!-- Floppy Disk Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">ABOUT US</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                           Tech & Ethics Club is a student-led community for builders, coders, designers, and engineers from all corners of tech â€” from computer science and robotics to AI, hardware, and beyond. We host hackathons and hands-on challenges that push members to not only build amazing things, but to think deeply about why theyâ€™re building them and who they're building for.
                        </p>
                        <p class="blueprint-text">
                            We believe technology isn't neutral â€” it shapes the world around us. Thatâ€™s why our focus goes beyond code. We explore the ethical impact of innovation, challenge ourselves to design for equity, privacy, sustainability, and inclusion, and create space for interdisciplinary collaboration.
                        </p>
                        <p class="blueprint-text">
                            Whether you're a beginner or an expert, a roboticist or a web dev, this is a club where you can build, compete, and grow â€” all while asking the big questions about techâ€™s role in society.
                        </p>
                    </div>
                </section>

                <!-- Python Code Screen Section -->
                <section class="section blueprint-section code-section">
                   <div class="section-header">
                    <!--    <h2 class="section-title">PYTHON CODE EXECUTION</h2> -->
                        <div class="section-line"></div>
                    </div>
                    <div class="code-container">
                        <div id="python-screen" class="python-screen">
                            <div class="screen-header">
                                <div class="screen-controls">
                                    <div class="control-dot red"></div>
                                    <div class="control-dot yellow"></div>
                                    <div class="control-dot green"></div>
                                </div>
                                <div class="screen-title">Python Terminal</div>
                            </div>
                            <div class="screen-content">
                                <div id="code-output" class="code-output">
                                    <div class="prompt">$ python main.py</div>
                                    <div id="typing-area" class="typing-area"></div>
                                    <div id="loading-indicator" class="loading-indicator hidden">
                                        <span class="loading-text">Executing...</span>
                                        <div class="loading-dots">
                                            <span></span>
                                            <span></span>
                                            <span></span>
                                        </div>
                                    </div>
                                    <div id="program-output" class="program-output hidden"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Touch Screen Interface Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">TOUCH SCREEN INTERFACE</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                        </p>
                        <p class="blueprint-text">
                            Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
                        </p>
                        <p class="blueprint-text">
                            The touch screen interface utilizes capacitive sensing technology to detect user input through electrical conductivity. Multi-touch capabilities enable complex gesture recognition and simultaneous input processing for enhanced user interaction.
                        </p>
                    </div>
                </section>

                <!-- Bezier Curves Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">BÃ‰ZIER CURVE SYSTEM</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                            BÃ©zier curves provide smooth, mathematically precise paths for vector graphics and animation systems. Control points define the curve's shape, allowing for complex geometric forms with minimal data points.
                        </p>
                        <p class="blueprint-text">
                            Quadratic and cubic BÃ©zier implementations offer different levels of complexity and control. The de Casteljau algorithm efficiently computes curve points through recursive subdivision techniques.
                        </p>
                        <p class="blueprint-text">
                            The system supports both open and closed curve paths, enabling the creation of complex shapes and smooth animations. Control point manipulation provides intuitive editing capabilities for designers and developers.
                        </p>
                    </div>
                </section>

                <!-- Mini Robot Walk Cycle Test Section -->
                <section class="section blueprint-section model-section">
                    <div class="section-header">
                        <h2 class="section-title">MINI ROBOT WALK CYCLE TEST</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="model-container">
                        <div id="mini-robot-viewer" class="robot-viewer"></div>
                    </div>
                </section>



                <!-- Small Robot Section -->
                <section class="section blueprint-section model-section">
                    <div class="section-header">
                        <h2 class="section-title">SMALL ROBOT</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="model-container">
                        <div id="small-robot-viewer" class="robot-viewer"></div>
                    </div>
                </section>



                <!-- System Overview Section -->
                <section class="section blueprint-section text-section">
                    <div class="section-header">
                        <h2 class="section-title">SYSTEM OVERVIEW</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="text-content">
                        <p class="blueprint-text">
                            This comprehensive software architecture integrates multiple subsystems to create a cohesive development environment. Each component operates independently while maintaining interoperability through standardized interfaces.
                        </p>
                        <p class="blueprint-text">
                            Performance optimization strategies include caching mechanisms, parallel processing pipelines, and memory management protocols. The modular design enables scalable deployment across various hardware configurations.
                        </p>
                        <p class="blueprint-text">
                            The system implements a layered architecture with clear separation of concerns between presentation, business logic, and data access layers. This design pattern promotes maintainability and facilitates future enhancements.
                        </p>
                    </div>
                </section>

                <!-- Cute Home Robot Section -->
                <section class="section blueprint-section model-section">
                    <div class="section-header">
                        <h2 class="section-title">CUTE HOME ROBOT</h2>
                        <div class="section-line"></div>
                    </div>
                    <div class="model-container">
                        <div id="cute-robot-viewer" class="robot-viewer"></div>
                    </div>
                </section>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <div class="footer-left">
                    <div class="footer-info">
                        <span class="footer-label">GENERATED:</span>
                        <span class="footer-value">2024-01-15</span>
                    </div>
                </div>
                <div class="footer-center">
                    <div class="footer-info">
                        <span class="footer-label">REVISION:</span>
                        <span class="footer-value">BETA-2.1</span>
                    </div>
                </div>
                <div class="footer-right">
                    <div class="footer-info">
                        <span class="footer-label">STATUS:</span>
                        <span class="footer-value">OPERATIONAL</span>
                    </div>
                </div>
            </div>
            <div class="footer-credits">
                <span class="credits-text">
                    3D Models: <a href="https://sketchfab.com/3d-models/robot-playground-59fc99d8dcb146f3a6c16dbbcc4680da" target="_blank">Robot Playground</a> by Hadrien59, 
                    <a href="https://sketchfab.com/3d-models/autonomous-robot-sweeper-0d285c3d015a4573ae1100d298935cb9" target="_blank">Autonomous Robot Sweeper</a> by Janis Zeps, 
                    <a href="https://sketchfab.com/3d-models/cute-home-robot-7b75f204eb3e42b6babd883773e0789d" target="_blank">Cute Home Robot</a> by Yandrack, 
                    <a href="https://sketchfab.com/3d-models/small-robot-0bfa872c2faa4b03a1e0508908db6e32" target="_blank">Small Robot</a> by TitMit 
                    via Sketchfab. Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>. Educational use.
                </span>
            </div>
        </footer>
    </div>



    <script>
        // Typewriter effect for the title
        function typeWriter(element, text, speed = 100) {
            let i = 0;
            element.innerHTML = '';
            
            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                }
            }
            
            type();
        }

        // Smooth scroll to sections
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            } else {
                // If section doesn't exist, show a placeholder message
                alert(`${sectionId.charAt(0).toUpperCase() + sectionId.slice(1)} section coming soon!`);
            }
        }

        // Three.js Robot Setup
        let scene, camera, renderer, controls, mixer, clock;
        let robotModel = null;

        function initRobotViewer() {
            const container = document.getElementById('robot-viewer');
            if (!container) return;

            // Add loading indicator
            container.innerHTML = '<div class="model-loading">LOADING ROBOT MODEL...</div>';

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9ff);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(1.5, 1.5, 1.5);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 15;
            controls.maxPolarAngle = Math.PI;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x0066ff, 0.5, 100);
            pointLight.position.set(-5, 5, -5);
            scene.add(pointLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Load the GLB model
            const loader = new THREE.GLTFLoader();
            loader.load(
                'Robot Playground.glb',
                function (gltf) {
                    robotModel = gltf.scene;
                    
                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(robotModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    
                    robotModel.scale.setScalar(scale);
                    robotModel.position.sub(center.multiplyScalar(scale));
                    
                    // Enable shadows
                    robotModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(robotModel);
                    
                    // Setup animations if available
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(robotModel);
                        clock = new THREE.Clock();
                        
                        gltf.animations.forEach((clip) => {
                            mixer.clipAction(clip).play();
                        });
                    }
                    
                    // Remove loading indicator
                    container.querySelector('.model-loading')?.remove();
                    
                    // Start animation loop
                    animate();
                },
                function (xhr) {
                    // Progress callback
                    const progress = (xhr.loaded / xhr.total) * 100;
                    const loadingElement = container.querySelector('.model-loading');
                    if (loadingElement) {
                        loadingElement.textContent = `LOADING ROBOT MODEL... ${Math.round(progress)}%`;
                    }
                },
                function (error) {
                    console.error('Error loading model:', error);
                    container.innerHTML = '<div class="model-loading">ERROR LOADING MODEL</div>';
                }
            );

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (mixer && clock) {
                mixer.update(clock.getDelta());
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('robot-viewer');
            if (!container) return;
            
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Three.js Sweeper Setup
        let sweeperScene, sweeperCamera, sweeperRenderer, sweeperControls, sweeperMixer, sweeperClock;
        let sweeperModel = null;

        function initSweeperViewer() {
            const container = document.getElementById('sweeper-viewer');
            if (!container) return;

            // Add loading indicator
            container.innerHTML = '<div class="model-loading">LOADING SWEEPER MODEL...</div>';

            // Scene setup
            sweeperScene = new THREE.Scene();
            sweeperScene.background = new THREE.Color(0xf8f9ff);

            // Camera setup
            sweeperCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            sweeperCamera.position.set(3, 3, 3);

            // Renderer setup
            sweeperRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            sweeperRenderer.setSize(container.clientWidth, container.clientHeight);
            sweeperRenderer.setPixelRatio(window.devicePixelRatio);
            sweeperRenderer.shadowMap.enabled = true;
            sweeperRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            sweeperRenderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(sweeperRenderer.domElement);

            // Controls
            sweeperControls = new THREE.OrbitControls(sweeperCamera, sweeperRenderer.domElement);
            sweeperControls.enableDamping = true;
            sweeperControls.dampingFactor = 0.05;
            sweeperControls.screenSpacePanning = false;
            sweeperControls.minDistance = 1;
            sweeperControls.maxDistance = 15;
            sweeperControls.maxPolarAngle = Math.PI;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            sweeperScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            sweeperScene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x0066ff, 0.5, 100);
            pointLight.position.set(-5, 5, -5);
            sweeperScene.add(pointLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            sweeperScene.add(gridHelper);

            // Load the GLB model
            const loader = new THREE.GLTFLoader();
            loader.load(
                'Autonomous Robot Sweeper.glb',
                function (gltf) {
                    sweeperModel = gltf.scene;
                    
                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(sweeperModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    
                    sweeperModel.scale.setScalar(scale);
                    sweeperModel.position.sub(center.multiplyScalar(scale));
                    
                    // Enable shadows
                    sweeperModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    sweeperScene.add(sweeperModel);
                    
                    // Setup animations if available
                    if (gltf.animations && gltf.animations.length > 0) {
                        sweeperMixer = new THREE.AnimationMixer(sweeperModel);
                        sweeperClock = new THREE.Clock();
                        
                        gltf.animations.forEach((clip) => {
                            sweeperMixer.clipAction(clip).play();
                        });
                    }
                    
                    // Remove loading indicator
                    container.querySelector('.model-loading')?.remove();
                    
                    // Start animation loop
                    animateSweeper();
                },
                function (xhr) {
                    // Progress callback
                    const progress = (xhr.loaded / xhr.total) * 100;
                    const loadingElement = container.querySelector('.model-loading');
                    if (loadingElement) {
                        loadingElement.textContent = `LOADING SWEEPER MODEL... ${Math.round(progress)}%`;
                    }
                },
                function (error) {
                    console.error('Error loading sweeper model:', error);
                    container.innerHTML = '<div class="model-loading">ERROR LOADING SWEEPER MODEL</div>';
                }
            );

            // Handle window resize
            window.addEventListener('resize', onSweeperWindowResize);
        }

        function animateSweeper() {
            requestAnimationFrame(animateSweeper);
            
            if (sweeperMixer && sweeperClock) {
                sweeperMixer.update(sweeperClock.getDelta());
            }
            
            sweeperControls.update();
            sweeperRenderer.render(sweeperScene, sweeperCamera);
        }

        function onSweeperWindowResize() {
            const container = document.getElementById('sweeper-viewer');
            if (!container) return;
            
            sweeperCamera.aspect = container.clientWidth / container.clientHeight;
            sweeperCamera.updateProjectionMatrix();
            sweeperRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Mini Robot Setup
        let miniScene, miniCamera, miniRenderer, miniControls, miniMixer, miniClock;
        let miniModel = null;

        function initMiniRobotViewer() {
            const container = document.getElementById('mini-robot-viewer');
            if (!container) return;

            container.innerHTML = '<div class="model-loading">LOADING MINI ROBOT MODEL...</div>';

            miniScene = new THREE.Scene();
            miniScene.background = new THREE.Color(0xf8f9ff);

            miniCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            miniCamera.position.set(2, 2, 2);

            miniRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            miniRenderer.setSize(container.clientWidth, container.clientHeight);
            miniRenderer.setPixelRatio(window.devicePixelRatio);
            miniRenderer.shadowMap.enabled = true;
            miniRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            miniRenderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(miniRenderer.domElement);

            miniControls = new THREE.OrbitControls(miniCamera, miniRenderer.domElement);
            miniControls.enableDamping = true;
            miniControls.dampingFactor = 0.05;
            miniControls.screenSpacePanning = false;
            miniControls.minDistance = 1;
            miniControls.maxDistance = 15;
            miniControls.maxPolarAngle = Math.PI;

            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            miniScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            miniScene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x0066ff, 0.5, 100);
            pointLight.position.set(-5, 5, -5);
            miniScene.add(pointLight);

            const gridHelper = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            miniScene.add(gridHelper);

            const loader = new THREE.GLTFLoader();
            loader.load(
                'Mini Robot Walk Cycle Test.glb',
                function (gltf) {
                    miniModel = gltf.scene;
                    
                    const box = new THREE.Box3().setFromObject(miniModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    
                    miniModel.scale.setScalar(scale);
                    miniModel.position.sub(center.multiplyScalar(scale));
                    
                    miniModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    miniScene.add(miniModel);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        miniMixer = new THREE.AnimationMixer(miniModel);
                        miniClock = new THREE.Clock();
                        
                        gltf.animations.forEach((clip) => {
                            miniMixer.clipAction(clip).play();
                        });
                    }
                    
                    container.querySelector('.model-loading')?.remove();
                    animateMini();
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    const loadingElement = container.querySelector('.model-loading');
                    if (loadingElement) {
                        loadingElement.textContent = `LOADING MINI ROBOT MODEL... ${Math.round(progress)}%`;
                    }
                },
                function (error) {
                    console.error('Error loading mini robot model:', error);
                    container.innerHTML = '<div class="model-loading">ERROR LOADING MINI ROBOT MODEL</div>';
                }
            );

            window.addEventListener('resize', onMiniWindowResize);
        }

        function animateMini() {
            requestAnimationFrame(animateMini);
            
            if (miniMixer && miniClock) {
                miniMixer.update(miniClock.getDelta());
            }
            
            miniControls.update();
            miniRenderer.render(miniScene, miniCamera);
        }

        function onMiniWindowResize() {
            const container = document.getElementById('mini-robot-viewer');
            if (!container) return;
            
            miniCamera.aspect = container.clientWidth / container.clientHeight;
            miniCamera.updateProjectionMatrix();
            miniRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Cute Home Robot Setup
        let cuteScene, cuteCamera, cuteRenderer, cuteControls, cuteMixer, cuteClock;
        let cuteModel = null;

        function initCuteRobotViewer() {
            const container = document.getElementById('cute-robot-viewer');
            if (!container) return;

            container.innerHTML = '<div class="model-loading">LOADING CUTE ROBOT MODEL...</div>';

            cuteScene = new THREE.Scene();
            cuteScene.background = new THREE.Color(0xf8f9ff);

            cuteCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            cuteCamera.position.set(2, 2, 2);

            cuteRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            cuteRenderer.setSize(container.clientWidth, container.clientHeight);
            cuteRenderer.setPixelRatio(window.devicePixelRatio);
            cuteRenderer.shadowMap.enabled = true;
            cuteRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            cuteRenderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(cuteRenderer.domElement);

            cuteControls = new THREE.OrbitControls(cuteCamera, cuteRenderer.domElement);
            cuteControls.enableDamping = true;
            cuteControls.dampingFactor = 0.05;
            cuteControls.screenSpacePanning = false;
            cuteControls.minDistance = 1;
            cuteControls.maxDistance = 15;
            cuteControls.maxPolarAngle = Math.PI;

            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            cuteScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            cuteScene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x0066ff, 0.5, 100);
            pointLight.position.set(-5, 5, -5);
            cuteScene.add(pointLight);

            const gridHelper = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            cuteScene.add(gridHelper);

            const loader = new THREE.GLTFLoader();
            loader.load(
                'Cute Home Robot.glb',
                function (gltf) {
                    cuteModel = gltf.scene;
                    
                    const box = new THREE.Box3().setFromObject(cuteModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    
                    cuteModel.scale.setScalar(scale);
                    cuteModel.position.sub(center.multiplyScalar(scale));
                    
                    cuteModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    cuteScene.add(cuteModel);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        cuteMixer = new THREE.AnimationMixer(cuteModel);
                        cuteClock = new THREE.Clock();
                        
                        gltf.animations.forEach((clip) => {
                            cuteMixer.clipAction(clip).play();
                        });
                    }
                    
                    container.querySelector('.model-loading')?.remove();
                    animateCute();
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    const loadingElement = container.querySelector('.model-loading');
                    if (loadingElement) {
                        loadingElement.textContent = `LOADING CUTE ROBOT MODEL... ${Math.round(progress)}%`;
                    }
                },
                function (error) {
                    console.error('Error loading cute robot model:', error);
                    container.innerHTML = '<div class="model-loading">ERROR LOADING CUTE ROBOT MODEL</div>';
                }
            );

            window.addEventListener('resize', onCuteWindowResize);
        }

        function animateCute() {
            requestAnimationFrame(animateCute);
            
            if (cuteMixer && cuteClock) {
                cuteMixer.update(cuteClock.getDelta());
            }
            
            cuteControls.update();
            cuteRenderer.render(cuteScene, cuteCamera);
        }

        function onCuteWindowResize() {
            const container = document.getElementById('cute-robot-viewer');
            if (!container) return;
            
            cuteCamera.aspect = container.clientWidth / container.clientHeight;
            cuteCamera.updateProjectionMatrix();
            cuteRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Small Robot Setup
        let smallScene, smallCamera, smallRenderer, smallControls, smallMixer, smallClock;
        let smallModel = null;

        function initSmallRobotViewer() {
            const container = document.getElementById('small-robot-viewer');
            if (!container) return;

            container.innerHTML = '<div class="model-loading">LOADING SMALL ROBOT MODEL...</div>';

            smallScene = new THREE.Scene();
            smallScene.background = new THREE.Color(0xf8f9ff);

            smallCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            smallCamera.position.set(2, 2, 2);

            smallRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            smallRenderer.setSize(container.clientWidth, container.clientHeight);
            smallRenderer.setPixelRatio(window.devicePixelRatio);
            smallRenderer.shadowMap.enabled = true;
            smallRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            smallRenderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(smallRenderer.domElement);

            smallControls = new THREE.OrbitControls(smallCamera, smallRenderer.domElement);
            smallControls.enableDamping = true;
            smallControls.dampingFactor = 0.05;
            smallControls.screenSpacePanning = false;
            smallControls.minDistance = 1;
            smallControls.maxDistance = 15;
            smallControls.maxPolarAngle = Math.PI;

            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            smallScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            smallScene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x0066ff, 0.5, 100);
            pointLight.position.set(-5, 5, -5);
            smallScene.add(pointLight);

            const gridHelper = new THREE.GridHelper(10, 10, 0x0000ff, 0x0000ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            smallScene.add(gridHelper);

            const loader = new THREE.GLTFLoader();
            loader.load(
                'Small Robot.glb',
                function (gltf) {
                    smallModel = gltf.scene;
                    
                    const box = new THREE.Box3().setFromObject(smallModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    
                    smallModel.scale.setScalar(scale);
                    smallModel.position.sub(center.multiplyScalar(scale));
                    
                    smallModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    smallScene.add(smallModel);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        smallMixer = new THREE.AnimationMixer(smallModel);
                        smallClock = new THREE.Clock();
                        
                        gltf.animations.forEach((clip) => {
                            smallMixer.clipAction(clip).play();
                        });
                    }
                    
                    container.querySelector('.model-loading')?.remove();
                    animateSmall();
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    const loadingElement = container.querySelector('.model-loading');
                    if (loadingElement) {
                        loadingElement.textContent = `LOADING SMALL ROBOT MODEL... ${Math.round(progress)}%`;
                    }
                },
                function (error) {
                    console.error('Error loading small robot model:', error);
                    container.innerHTML = '<div class="model-loading">ERROR LOADING SMALL ROBOT MODEL</div>';
                }
            );

            window.addEventListener('resize', onSmallWindowResize);
        }

        function animateSmall() {
            requestAnimationFrame(animateSmall);
            
            if (smallMixer && smallClock) {
                smallMixer.update(smallClock.getDelta());
            }
            
            smallControls.update();
            smallRenderer.render(smallScene, smallCamera);
        }

        function onSmallWindowResize() {
            const container = document.getElementById('small-robot-viewer');
            if (!container) return;
            
            smallCamera.aspect = container.clientWidth / container.clientHeight;
            smallCamera.updateProjectionMatrix();
            smallRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Python Code Animation
        let animationRunning = false;
        let animationTimeouts = [];

        function clearAllTimeouts() {
            animationTimeouts.forEach(timeout => clearTimeout(timeout));
            animationTimeouts = [];
        }

        function initPythonCodeAnimation() {
            // Prevent multiple animations from running simultaneously
            if (animationRunning) {
                clearAllTimeouts();
            }
            
            animationRunning = true;

            const pythonCode = `user = "interested"

if user == "interested":
    print("Join our Tech & Ethics Club!")
    print("Build amazing things with purpose!")
    print("We'd love to have you! ðŸš€")`;

            const output = `Join our Tech & Ethics Club!
Build amazing things with purpose!
We'd love to have you! ðŸš€`;

            const typingArea = document.getElementById('typing-area');
            const loadingIndicator = document.getElementById('loading-indicator');
            const programOutput = document.getElementById('program-output');

            if (!typingArea || !loadingIndicator || !programOutput) {
                animationRunning = false;
                return;
            }

            function clearScreen() {
                // Completely reset all content
                typingArea.textContent = '';
                typingArea.innerHTML = '';
                loadingIndicator.classList.add('hidden');
                programOutput.classList.add('hidden');
                programOutput.textContent = '';
                programOutput.innerHTML = '';
            }

            function showOutput() {
                loadingIndicator.classList.add('hidden');
                programOutput.classList.remove('hidden');
                programOutput.textContent = output;
                
                // After showing output, clear and restart
                const timeout1 = setTimeout(() => {
                    clearScreen();
                    const timeout2 = setTimeout(() => {
                        startTyping();
                    }, 1000);
                    animationTimeouts.push(timeout2);
                }, 3000);
                animationTimeouts.push(timeout1);
            }

            function showLoading() {
                loadingIndicator.classList.remove('hidden');
                const timeout = setTimeout(showOutput, 2000);
                animationTimeouts.push(timeout);
            }

            function startTyping() {
                // Ensure screen is completely clear before starting
                clearScreen();
                
                let currentIndex = 0;
                let currentLine = 0;
                const lines = pythonCode.split('\n');

                function typeNext() {
                    if (currentLine < lines.length) {
                        const line = lines[currentLine];
                        if (currentIndex < line.length) {
                            typingArea.textContent += line[currentIndex];
                            currentIndex++;
                            const timeout = setTimeout(typeNext, 50);
                            animationTimeouts.push(timeout);
                        } else {
                            typingArea.textContent += '\n';
                            currentLine++;
                            currentIndex = 0;
                            const timeout = setTimeout(typeNext, 100);
                            animationTimeouts.push(timeout);
                        }
                    } else {
                        // Typing complete, show loading
                        const timeout = setTimeout(showLoading, 500);
                        animationTimeouts.push(timeout);
                    }
                }

                typeNext();
            }

            // Start the animation cycle
            startTyping();
        }

        // Intersection Observer for animations
        function initAnimations() {
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('animate-in');
                        
                        // Initialize 3D viewer when model section comes into view
                        if (entry.target.classList.contains('model-section')) {
                            setTimeout(() => {
                                // Check which robot viewer to initialize
                                if (entry.target.querySelector('#sweeper-viewer')) {
                                    initSweeperViewer();
                                } else if (entry.target.querySelector('#mini-robot-viewer')) {
                                    initMiniRobotViewer();
                                } else if (entry.target.querySelector('#cute-robot-viewer')) {
                                    initCuteRobotViewer();
                                } else if (entry.target.querySelector('#small-robot-viewer')) {
                                    initSmallRobotViewer();
                                } else {
                                    initRobotViewer();
                                }
                            }, 500);
                        }
                        
                        // Initialize Python code animation when code section comes into view
                        if (entry.target.classList.contains('code-section') && !animationRunning) {
                            setTimeout(() => {
                                initPythonCodeAnimation();
                            }, 500);
                        }
                    }
                });
            }, observerOptions);

            // Observe all blueprint sections
            document.querySelectorAll('.blueprint-section').forEach(section => {
                observer.observe(section);
            });
        }



        // Start everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const titleElement = document.getElementById('typewriter-title');
            const originalText = titleElement.textContent;
            typeWriter(titleElement, originalText, 150);
            
            // Initialize animations after a short delay
            setTimeout(() => {
                initAnimations();
            }, 1000);
        });
    </script>
</body>
</html> 